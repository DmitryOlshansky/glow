# May change 
type Id = Array[u8, 32] # public key - ed25519
type SecretKey = Array[u8, 32] # secret key for Id
type Signature = Array[u8, 64] # signature of Id key
type Addr = Array[u8, 16] # addr, derived from Id

type PubKey = Array[u8, 32] # public key in key exchange
type AeadKey = Array[u8, 32]

type MAC = Array[u8, 16] # for reference the size of AEAD tag
type Nonce = Array[u8, 24] # nonce that identifies each request, nodes use it to dedup requests (has time based + counter based parts)

type KeyExchange = struct {
    id: PubKey
    pk: PubKey
    signature: Signature # signed by cluster secret key
}

type LinkClass {
    speed: u8   # 1 + log10 scale of kb/s 
    latency: u8 # order of magnitude in 1 + log10 scale of us, 0 - immediate (shared memory)
    flags: u8   # bits: 0 - reliable/unreliable, 1 - ordered/unordered, 2 - encrypted/plain-text
}

type LSP = struct {
    up: Id # up > down lexicographically
    down: Id
    state: u8
    class: LinkClass
    mtu: vu
    rev: vu
}

type LinkState = struct {
    peer: Id
    state: u16
    mtu: vu
}

type Ownership = struct {
    master: vu
    slave: vu
}

type Resource = struct {
    type: Id
    id: Id
}

type GlowPacket = struct {
    src: Id
    dest: Id
    nonce: Nonce
    type: u8    # message, request, response, error, cancel
    offset: vu  # offset for this fragment
    size: vu    # total size of fragmented packet
    payload: Array[u8]
    mac: Array[u8, 16]
}

# For any message sender knows it's nonce
# every time there is a need for nonce with signature, 
# that nonce is prepended : signature = Sign(nonce || flatten(args - signature))
proto glowlet {
    # These 2 raw messages shuld be sent by both parties simultaneously
    # raw - without MAC and encryption, keyExchange pairs are persisted for short TTL
    raw start(kx: KeyExchange)
    # establish our side of link with this node by providing our key
    raw establish(kxNonce: Nonce, encryptedKey: AeadKey)

    # HB is sent over established links periodically with cluster addr as destination
    # First case - if there is any change detected in response (by rev) - flooded to all neibours except this one
    # Second case - if a new addr is discovered - floods to all of new addrs
    # (both could apply)
    def heartbeat(resources: Array[Resource], links: Array[LSP], owners: Array[Ownership]): none

    # label is a human-readable name (must follow a convention and be node-wide unique)
    # signature is done by key for id
    def create(label: Array[u8], type: Id, id: Id, signature: Signature): Id

    # configure link parameters, only for link resource
    def configureLink(id: link, up: u8, mtu: vu, class: LinkClass): void

    # same for reverse operation, needs secret key for that resource Id
    def destroy(id: Id, signature: Signature): void
}

# link has a unique contract - it also gets a separate send/recv raw packet queues (either via shared memory with proto glowlet or just an embedding API)
# normally each process has exactly one send/recv packet queue and it's packets are (pre-post) processed by proto glowlet (signatures etc.)
proto link {}

# foreign network proto 
proto fni {
    def ordered(protocol: Array[u8]): ordered_stream & socket
    def unordered(protocol: Array[u8]): unordered_stream & socket
}

proto socket {
    def bind(fna: Array[u8]): void
    def connect(fna: Array[u8]): void
    def listen(backlog: vu): void
    def accept(): Socket
    def close(): void
}

# base for resources which can be (un)subscribed to
proto publisher {
    def subscribe(id: Id): void
    def unsubscribe(id: Id): void
}

# 
proto ordered_stream : publisher {
    def write(seqNo: u64, data: Array[u8]): void   
}

# 
proto unordered_stream : publisher {
    def write(msg: Array[u8]): void
}
